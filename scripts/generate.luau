local fs = require("@lune/fs")
local process = require("@lune/process")
local DateTime = require("@lune/datetime")
local serde = require("@lune/serde")

-- Read versions from JSON file
local VersionsJSON = fs.readFile("./tools/versions.json")
local Versions = serde.decode("json", VersionsJSON)

-- Run benchmark in Roblox
local robloxResult = process.spawn("run-in-roblox", {"--place", "Benchmark.rbxl", "--script", "./scripts/run.luau"})
assert(robloxResult.ok, `Unable to run benchmark, {robloxResult.stderr}`)

-- Split stdout by separator
local stdout = string.split(robloxResult.stdout, "--RESULTS JSON--")
table.remove(stdout, 1)

-- Parse result JSON
local result: {[string]: {[string]: Benchmark}};
for _, line in stdout do
    line = string.gsub(line, "\n", "")
    if string.sub(line, 1, 1) == "{" then
        result = serde.decode("json", line)
        break 
    end
end

-- Get current time
local currentTime = DateTime.now()
local formattedTime = currentTime:formatUniversalTime("%D %H:%M:%S UTC", "en")

--[=[
    Function to create header 

    @param readme boolean -- Create header for readme or results 
]=]
local function createHeader(readme: boolean?)
    local FILE_NAME = readme and "README.md" or "RESULTS.md"
    local SEPARATOR = readme and "*The tables below were automatically generated by this [script](https://github.com/robloxjw02-dev/roblox-network-benchmark/blob/main/generate.luau).*\n" or "\n\n---\n\n"
    local data = fs.readFile(FILE_NAME)

    local headerData = string.split(data, SEPARATOR)
    local header = string.gsub(readme and headerData[1] or data, "\n*$", "") 
    if readme then
        local LAST_UPDATED_PATTERN = "%(Last Updated %d+/%d+/%d+ %d+:%d+:%d+ UTC%)"
        
        local hasResultsHeader = string.match(header, '## Results')
        if not hasResultsHeader then
            header ..= "\n## Results"
        end
    
        local isFirstUpdate = not string.match(header, LAST_UPDATED_PATTERN)
        
        header = isFirstUpdate  and header .. " (Last Updated " .. formattedTime .. ")\n`P[NUMBER]` = [NUMBER] Percentile" or string.gsub(header, LAST_UPDATED_PATTERN, "(Last Updated " .. formattedTime .. ")")
       
        header ..= `\n\n{SEPARATOR}`
        header ..= `\n## Tool Versions` 
        
        for Tool, Version in Versions do
            header ..= `\n\`{Tool}\`: {Version}  `
        end
    
        return header
    else
        local lastNumber: number = 0

        for number in string.gmatch(data, "Benchmark%s*(%d+)") do
            lastNumber = (tonumber(number) :: number) 
        end

        local targetNumber = lastNumber + 1
        header ..= "\n\n---"
        header ..= `\n\n## Benchmark {targetNumber} ({formattedTime})\n`
        header ..= `\n### Tool Versions`

        for Tool, Version in Versions do
            header ..= `\n\`{Tool}\`: {Version}  `
        end 

        return header
    end 
end

--> Start writing contents for README.md and RESULTS.md
local contents = createHeader(true)
local resultsContents = createHeader()

--[=[
    Function to query system specifications using WMIC

    @param component string
    @param properties string
    @return table(string) 
]=]
local function queryWMIC(component: string, properties: string): {string}
    local spawnResult = process.spawn("wmic", {component, "get", properties})
    assert(spawnResult.ok, spawnResult.stderr)

    local lines = string.split(spawnResult.stdout, "\n")

    --> Remove header and padding
    table.remove(lines, 1)
    table.remove(lines, #lines)
    table.remove(lines, #lines)

    --> Parse text
    local queryResult = {}
    for index, line in lines do
        --> Remove padding
        line = string.gsub(line, "\r", "")
        line = string.sub(line, 1, #line - 1)

        if component == "cpu" then
            table.insert(queryResult, line)
            continue
        end

        local subResult = {}
        local lineResults = string.split(line, " ")
        for index, result in lineResults do
            --> Ignore empty lines
            if string.gsub(result, "%c", "") == "" then
                continue
            end

            table.insert(subResult, result)
        end

        table.insert(queryResult, subResult)
    end

    return queryResult
end

--[=[
    Function to write computer specifications 
]=]
local function writeComputerSpecs(): ()
    local Data = ""
    local ResultsData = ""
    local Processor = queryWMIC("cpu", "name")
    local MemorySticks = queryWMIC("memorychip", "Capacity,Speed")
   
    Data ..= `\n## Computer Specs`
    ResultsData ..= `\n### Computer Specs`
    Data ..= `\nProcessor: \`{Processor[1]}\`  `
    ResultsData ..= `\nProcessor: \`{Processor[1]}\`  `

    for Slot, Stick in MemorySticks do
        local Capacity = (tonumber(Stick[1]) :: number) // 1e+9
        Data ..= `\nMemory #{Slot}: \`{Capacity}GB {Stick[2]}\`  `
        ResultsData ..= `\nMemory #{Slot}: \`{Capacity}GB {Stick[2]}\`  `
    end

    contents ..= Data
    resultsContents ..= ResultsData
end

type Benchmark = {
    Sent: number,
    Receive: number,
    Bandwidth: {number},
    Framerate: {number}
}


--[=[
    Function to format integer to use comma

    @param integer number -- The integer to format
    @return string -- Returns formatted integer
]=]
local function formatInteger(integer: number)
    local _, _, minus, int, fraction = string.find(tostring(integer), '([-]?)(%d+)([.]?%d*)')
    -- reverse the int-string and append a comma to all blocks of 3 digits
    int = string.gsub(string.reverse(int), "(%d%d%d)", "%1,")
    -- reverse the int-string back remove an optional comma and put the 
    -- optional minus and fractional part back
    return minus .. string.gsub(string.reverse(int), "^,", "") .. fraction
end

--[=[
    Function to write benchmark results

    @param benchmarks { [string]: { [string]: Benchmark }}
]=]
local function writeBenchmarkResults(benchmarks: { [string]: { [string]: Benchmark}}): ()
    local metrics = {
        {
            Label = "FPS",
            Samples = "Framerate"
        },
        {
            Label = "Kbps",
            Samples = "Bandwidth"
        }
    }

    --> Sort tools alphabetically
    local benchmarksName = {}
    for Name, Benchmarks in benchmarks do
        table.insert(benchmarksName, Name)
    end

    table.sort(benchmarksName, function(a, b)
        return #a < #b
    end)

    for _, benchmarkName in benchmarksName do
        local results: {[string]: Benchmark } = benchmarks[benchmarkName]
        local output = `\n## [{benchmarkName}](https://github.com/robloxjw02-dev/roblox-network-benchmark/blob/main/src/shared/benches/{benchmarkName}.luau)\n`
        local resultsOutput = `\n### [{benchmarkName}](https://github.com/robloxjw02-dev/roblox-network-benchmark/blob/main/src/shared/benches/{benchmarkName}.luau)\n`

        for index, metric in metrics do
            if index > 1 then
                output ..= "\n\n"
                resultsOutput ..= "\n\n"
            end

            output ..= `|Tool ({metric.Label})|Median|P0|P80|P90|P95|P100|Data Sent|Data Receive|Loss (%)|`
            output ..= `\n|---|---|---|---|---|---|---|---|---|---|`
            resultsOutput ..= `|Tool ({metric.Label})|Median|P0|P80|P90|P95|P100|Data Sent|Data Receive|Loss (%)|`
            resultsOutput ..= `\n|---|---|---|---|---|---|---|---|---|---|`
            for tool, result in results do
                local loss = math.floor((1 - (result.Receive / result.Sent)) * 100)
                if loss > 50 then
                    output ..= `\n|{tool}|-|-|-|-|-|-|{loss}%`
                    resultsOutput ..= `\n|{tool}|-|-|-|-|-|-|{loss}%`
                    continue
                end

                local numbers = result[metric.Samples]
                local formatted = table.create(#numbers)
                for index, value in numbers do
                    formatted[index] = string.format("%.2f", value)
                end

                output ..= `\n|{tool}|{table.concat(formatted, "|")}|{formatInteger(result.Sent)}|{formatInteger(result.Receive)}|{loss}%|`
                resultsOutput ..= `\n|{tool}|{table.concat(formatted, "|")}|{formatInteger(result.Sent)}|{formatInteger(result.Receive)}|{loss}%|`
            end
        end

        contents ..= output
        resultsContents ..= resultsOutput
    end
end

--> Write computer specifications
writeComputerSpecs()

--> Write benchmark results 
writeBenchmarkResults(result)

--> Output results
fs.writeFile("README.md", contents)
fs.writeFile("RESULTS.md", resultsContents)
print("Success")