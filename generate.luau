local fs = require("@lune/fs")
local process = require("@lune/process")
local DateTime = require("@lune/datetime")
local serde = require("@lune/serde")

-- Read versions from JSON file
local VersionsJSON = fs.readFile("./tools/versions.json")
local Versions = serde.decode("json", VersionsJSON)

-- Run benchmark in Roblox
local RobloxResult = process.spawn("run-in-roblox", {"--place", "Benchmark.rbxl", "--script", "run.luau"})
assert(RobloxResult.ok, `Unable to run benchmark, {RobloxResult.stderr}`)

-- Split stdout by separator
local Stdout = string.split(RobloxResult.stdout, "--RESULTS JSON--")
table.remove(Stdout, 1)

-- Parse result JSON
local Result: {[string]: {[string]: Benchmark}};
for _, Line in Stdout do
    Line = string.gsub(Line, "\n", "")
    if string.sub(Line, 1, 1) == "{" then
        Result = serde.decode("json", Line)
        break 
    end
end

-- Get current time
local currentTime = DateTime.now()
local formattedTime = currentTime:formatUniversalTime("%D %H:%M:%S UTC", "en")

--[=[
    Function to create header 

    @param readme boolean -- Create header for readme or results 
]=]
local function CreateHeader(readme: boolean?)
    local FILE_NAME = readme and "README.md" or "RESULTS.md"
    local SEPARATOR = readme and "*The tables below were automatically generated by this [script](https://github.com/robloxjw02-dev/roblox-network-benchmark/blob/main/generate.luau).*\n" or "\r\n\r\n---\r\n\r\n"
    local data = fs.readFile(FILE_NAME)

    local headerData = string.split(data, SEPARATOR)
    local header = string.gsub(headerData[readme and 1 or #headerData], "\n*$", "")
    if readme then
        local LAST_UPDATED_PATTERN = "%(Last Updated %d+/%d+/%d+ %d+:%d+:%d+ UTC%)"
        
        local hasResultsHeader = string.match(header, '## Results')
        if not hasResultsHeader then
            header ..= "\n## Results"
        end
    
        local isFirstUpdate = not string.match(header, LAST_UPDATED_PATTERN)
        
        header = isFirstUpdate  and header .. " (Last Updated " .. formattedTime .. ")\n`P[NUMBER]` = [NUMBER] Percentile" or string.gsub(header, LAST_UPDATED_PATTERN, "(Last Updated " .. formattedTime .. ")")
       
        header ..= `\n\n{SEPARATOR}`
        header ..= `\n## Tool Versions` 
        
        for Tool, Version in Versions do
            header ..= `\n\`{Tool}\`: {Version}  `
        end
    
        return header
    else
        local lastNumber: number = 0

        for number in string.gmatch(data, "Benchmark%s*(%d+)") do
            lastNumber = (tonumber(number) :: number) 
        end

        local targetNumber = lastNumber + 1
        header ..= `\n\n## Benchmark {targetNumber} ({formattedTime})\n`
        header ..= `\n### Tool Versions`

        for Tool, Version in Versions do
            header ..= `\n\`{Tool}\`: {Version}  `
        end 

        return header
    end 
end

--> Start writing contents for README.md and RESULTS.md
local Contents = CreateHeader(true)
local ResultsContents = CreateHeader()

--[=[
    Function to query system specifications using WMIC

    @param Component string
    @param Properties string
    @return { string }
]=]
local function QueryWMIC(Component: string, Properties: string): {string}
    local SpawnResult = process.spawn("wmic", {Component, "get", Properties})
    assert(SpawnResult.ok, SpawnResult.stderr)

    local Lines = string.split(SpawnResult.stdout, "\n")

    --> Remove header and padding
    table.remove(Lines, 1)
    table.remove(Lines, #Lines)
    table.remove(Lines, #Lines)

    --> Parse text
    local QueryResult = {}
    for Index, Line in Lines do
        --> Remove padding
        Line = string.gsub(Line, "\r", "")
        Line = string.sub(Line, 1, #Line - 1)

        if Component == "cpu" then
            table.insert(QueryResult, Line)
            continue
        end

        local SubResult = {}
        local LineResults = string.split(Line, " ")
        for Index, Result in LineResults do
            --> Ignore empty lines
            if string.gsub(Result, "%c", "") == "" then
                continue
            end

            table.insert(SubResult, Result)
        end

        table.insert(QueryResult, SubResult)
    end

    return QueryResult
end

--[=[
    Function to write computer specifications 
]=]
local function WriteComputerSpecs(): ()
    local Data = ""
    local ResultsData = ""
    local Processor = QueryWMIC("cpu", "name")
    local MemorySticks = QueryWMIC("memorychip", "Capacity,Speed")
   
    Data ..= `\n## Computer Specs`
    ResultsData ..= `\n### Computer Specs`
    Data ..= `\nProcessor: \`{Processor[1]}\`  `
    ResultsData ..= `\nProcessor: \`{Processor[1]}\`  `

    for Slot, Stick in MemorySticks do
        local Capacity = tonumber(Stick[1])
        Capacity //= 1e+9
        Data ..= `\nMemory #{Slot}: \`{Capacity}GB {Stick[2]}\`  `
        ResultsData ..= `\nMemory #{Slot}: \`{Capacity}GB {Stick[2]}\`  `
    end

    Contents ..= Data
    ResultsContents ..= ResultsData
end

type Benchmark = {
    Sent: number,
    Receive: number,
    Bandwidth: {number},
    Framerate: {number}
}


--[=[
    Function to format integer to use comma

    @param integer number -- The integer to format
    @return string -- Returns formatted integer
]=]
local function FormatInteger(integer: number)
    local _, _, minus, int, fraction = string.find(tostring(integer), '([-]?)(%d+)([.]?%d*)')
    -- reverse the int-string and append a comma to all blocks of 3 digits
    int = string.gsub(string.reverse(int), "(%d%d%d)", "%1,")
    -- reverse the int-string back remove an optional comma and put the 
    -- optional minus and fractional part back
    return minus .. string.gsub(string.reverse(int), "^,", "") .. fraction
end

--[=[
    Function to write benchmark results

    @param benches { [string]: { [string]: Benchmark }}
]=]
local function WriteBenchmarkResults(Benches: { [string]: { [string]: Benchmark}}): ()
    local Metrics = {
        {
            Label = "FPS",
            Samples = "Framerate"
        },
        {
            Label = "Kbps",
            Samples = "Bandwidth"
        }
    }
    --> Sort tools alphabetically
    local BenchesName = {}
    for Name, Benchmarks in Benches do
        table.insert(BenchesName, Name)
    end

    table.sort(BenchesName, function(a, b)
        return #a < #b
    end)


    for _, Name in BenchesName do
        local Results: {[string]: Benchmark } = Benches[Name]
        local Output = `\n## [{Name}](https://github.com/robloxjw02-dev/roblox-network-benchmark/blob/main/src/shared/benches/{Name}.luau)\n`
        local ResultsOutput = `\n### [{Name}](https://github.com/robloxjw02-dev/roblox-network-benchmark/blob/main/src/shared/benches/{Name}.luau)\n`
   
        for Index, Metric in Metrics do
            if Index > 1 then
                Output ..= "\n\n"
                ResultsOutput ..= "\n\n"
            end

            Output ..= `|Tool ({Metric.Label})|Median|P0|P80|P90|P95|P100|Data Sent|Data Receive|Loss (%)|`
            Output ..= `\n|---|---|---|---|---|---|---|---|---|---|`
            ResultsOutput ..= `|Tool ({Metric.Label})|Median|P0|P80|P90|P95|P100|Data Sent|Data Receive|Loss (%)|`
            ResultsOutput ..= `\n|---|---|---|---|---|---|---|---|---|---|`
            for Tool, Result in Results do
                local Loss = math.floor((1 - (Result.Receive / Result.Sent)) * 100)
                if Loss > 50 then
                    Output ..= `\n|{Tool}|-|-|-|-|-|-|{Loss}%`
                    ResultsOutput ..= `\n|{Tool}|-|-|-|-|-|-|{Loss}%`
                    continue
                end

                local Numbers = Result[Metric.Samples]
                local Formatted = table.create(#Numbers)
                for Index, Value in Numbers do
                    Formatted[Index] = string.format("%.2f", Value)
                end

                Output ..= `\n|{Tool}|{table.concat(Formatted, "|")}|{FormatInteger(Result.Sent)}|{FormatInteger(Result.Receive)}|{Loss}%|`
                ResultsOutput ..= `\n|{Tool}|{table.concat(Formatted, "|")}|{FormatInteger(Result.Sent)}|{FormatInteger(Result.Receive)}|{Loss}%|`
            end
        end

        Contents ..= Output
        ResultsContents ..= ResultsOutput
    end

    ResultsContents ..= "\n\n---"
end

--> Write computer specifications
WriteComputerSpecs()

--> Write Benchmark Results
WriteBenchmarkResults(Result)

--> Output results
fs.writeFile("README.md", Contents)
fs.writeFile("RESULTS.md", ResultsContents)
print("Success")